<------------------------- Insertion Sort --------------------->

#include <bits/stdc++.h>
using namespace std;

void insertionSort(int arr[], int n){
    for(int i=1; i<n; i++){
        int temp = arr[i];
        int j = i-1;
        while(j>=0 && arr[j]>temp){
            arr[j+1]=arr[j];
            j--;
        }
        arr[j+1]=temp;
    }
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }
}

int main(){
    int arr[5]={5,1,14,2,5};
    int n=5;
    insertionSort(arr, n);
    return 0; 
}

Worst complexity: n^2
Average complexity: n^2
Best complexity: n
Space complexity: 1
Method: Insertion
Stable: Yes


<------------------------- Bubble Sort -------------------------------->
#include <bits/stdc++.h>
using namespace std;

void bubbleSort(int arr[], int n){
    for(int i=0; i<n-1; i++){
        int flag=0;
        for(int j=0; j<n-1-i; j++){
            if(arr[j]>arr[j+1]){
                int temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
                flag=1;
            }
        }
        if(flag==0){
            break;
        }
    }
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;
}

int main(){
    int arr[5] = {23,1,4,4,21};
    int n=5;
    bubbleSort(arr,n);
    return 0;
}

Worst complexity: n^2
Average complexity: n^2
Best complexity: n
Space complexity: 1
Method: Exchanging
Stable: Yes

<----------------------------------- Selection Sort ---------------------------------->
#include<iostream>
#include<string>
using namespace std;

void selectionSort(int arr[], int n){
    for(int i=0; i<n-1; i++){
        int temp=i;
        for(int j=i+1; j<n; j++){
            if(arr[j]<arr[temp]){
                temp=j;
            }
        }
        if(temp!=i){
            swap(arr[i],arr[temp]);
        }
    }
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;
}

int main(){
    int arr[5] = {12,56,2,1,7};
    int n = 5;
    selectionSort(arr,n);
    return 0;
}

Worst complexity: n^2
Average complexity: n^2
Best complexity: n^2
Space complexity: 1
Method: Selection
Stable: No

<------------------------------ Merge Sort ----------------------------------------->
#include <iostream>
using namespace std;
 
// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r)
{
    int n1 = m - l + 1;
    int n2 = r - m;
 
    // Create temp arrays
    int L[n1], R[n2];
 
    // Copy data to temp arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    // Merge the temp arrays back into arr[l..r]
 
    // Initial index of first subarray
    int i = 0;
 
    // Initial index of second subarray
    int j = 0;
 
    // Initial index of merged subarray
    int k = l;
 
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
 
    // Copy the remaining elements of
    // L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
 
    // Copy the remaining elements of
    // R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
 
// l is for left index and r is
// right index of the sub-array
// of arr to be sorted */
void mergeSort(int arr[],int l,int r){
    if(l>=r){
        return;//returns recursively
    }
    int m =l+ (r-l)/2;
    mergeSort(arr,l,m);
    mergeSort(arr,m+1,r);
    merge(arr,l,m,r);
}
 
// UTILITY FUNCTIONS
// Function to print an array
void printArray(int A[], int size)
{
    for (int i = 0; i < size; i++)
        cout << A[i] << " ";
}
 
// Driver code
int main()
{
    int arr[] = { 12, 11, 13, 5, 6, 7 };
    int arr_size = sizeof(arr) / sizeof(arr[0]);
 
    cout << "Given array is \n";
    printArray(arr, arr_size);
 
    mergeSort(arr, 0, arr_size - 1);
 
    cout << "\nSorted array is \n";
    printArray(arr, arr_size);
    return 0;
}

Inventor: John von Neumann
Worst complexity: n*log(n)
Average complexity: n*log(n)
Best complexity: n*log(n)
Space complexity: n
Method: Merging
Stable: Yes

<--------------------------------- Quick Sort --------------------------------------->
#include<bits/stdc++.h>
using namespace std;

int partition(int arr[], int lb, int ub){
    int pivot = arr[lb];
    int start = lb;
    int end = ub;

    while(start<end){
        while(arr[start]<=pivot){
            start++;
        }
        while(arr[end]>pivot){
            end--;
        }
        if(start<end){
            swap(arr[start], arr[end]);
        }
    }
    swap(arr[lb],arr[end]);
    return end;
}

void quickSort(int arr[], int lb, int ub){
    if(lb<ub){
        int loc = partition(arr,lb,ub);
        if(loc==ub){
            partition(arr,lb,loc-1);
        }
        else{
            partition(arr,lb,loc-1);    
            partition(arr,loc+1,ub);
        }
    }
}

int main(){
    int arr[] = {12,3,1,4,1};
    int n = sizeof(arr)/sizeof(arr[0]);
    quickSort(arr,0,n-1);
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;

    return 0;
}

Inventor: Tony Hoare
Worst complexity: n^2
Average complexity: n*log(n)
Best complexity: n*log(n)
Method: Partitioning
Stable: No
Class: Comparison sort

<------------------------------------ Count Sort ---------------------------------------->
#include<bits/stdc++.h>
using namespace std;

void countSort(int arr[], int n){
    int k = arr[0];
    for(int i=0; i<n; i++){
        k = max(k,arr[i]);
    }
    int count[n] = {0};
    for(int i=0; i<n; i++){
        count[arr[i]]++; 
    }

    for(int i=1; i<=k; i++){
        count[i]+=count[i-1];
    }

    int output[n] = {0};
    for(int i=n-1; i>=0; i--){
        output[--count[arr[i]]] = arr[i];
    }

    for(int i=0; i<n; i++){
        arr[i] = output[i];
    }
}

int main(){
    int arr[] = {5,3,1,2,4,2,1,3,2,5};
    int n = sizeof(arr)/sizeof(arr[0]);
    countSort(arr,n);
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;
}

Worst complexity: n+r
Average complexity: n+r
Space complexity: n+r
Stable: Yes
Class: Non-comparison sort

<------------------------------------ Shell Sort --------------------------------------->
#include<bits/stdc++.h>
using namespace std;

void shellSort(int arr[], int n){
    int gap;
    for(gap=n/2; gap>=1; gap/=2){
        for(int i=gap; i<n; i++){
            for(int j=i-gap; j>=0; j-=gap){
                if(arr[j+gap]>arr[j]){
                    break;
                }
                else{
                    swap(arr[j+gap], arr[j]);
                }
            }
        }
    }
}

int main(){
    int arr[] = {23,7,15,19,31,29,9,5,2};
    int n = sizeof(arr)/sizeof(arr[0]);
    shellSort(arr,n);
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;
    return 0;
}

Inventor: Donald Shell
Worst complexity: Depends on gap sequence
Average complexity: n*log(n)^2 or n^(3/2)
Best complexity: n
Method: Insertion
Stable: No
Class: Comparison sort

<------------------------------------ Radix Sort using count method ----------------------------------->

#include<bits/stdc++.h>
using namespace std;

void countSort(int arr[], int n, int pos);

int getMax(int arr[], int n)
{
    int mx = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}

void radixSort(int arr[], int n){
    int pos;
    int k = getMax(arr, n);
    for(pos=1; k/pos>0; pos*=10){
        countSort(arr,n,pos);
    }
}

void countSort(int arr[], int n, int pos){
    int count[10] = {0};
    for(int i=0; i<n; i++){
        count[(arr[i]/pos)%10]++;
    }

    for(int i=1; i<10; i++){
        count[i]+=count[i-1];
    }

    int output[n] = {0};
    for(int i=n-1; i>=0; i--){
        output[--count[(arr[i]/pos)%10]] = arr[i];
    }

    for(int i=0; i<n; i++){
        arr[i] = output[i];
    }
}

int main(){
    int arr[] = {23,7,15,19,31,29,9,5,2};
    int n = sizeof(arr)/sizeof(arr[0]);
    radixSort(arr,n);
    for(int i=0; i<n; i++){
        cout<<arr[i]<<" ";
    }cout<<endl;
    return 0;
}

Worst complexity: n*k/d
Average complexity: n*k/d
Space complexity: n+2^d
Stable: Yes
Class: Non-comparison sort

<-------------------------------- Radix Sort Using Bucket method ------------------------------------->